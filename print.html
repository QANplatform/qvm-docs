<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="workflow/index.html"><strong aria-hidden="true">2.</strong> Generic workflow</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="workflow/api.html"><strong aria-hidden="true">2.1.</strong> Common API</a></li><li class="chapter-item expanded "><a href="workflow/write.html"><strong aria-hidden="true">2.2.</strong> Writing a contract</a></li><li class="chapter-item expanded "><a href="workflow/compile.html"><strong aria-hidden="true">2.3.</strong> Compiling a contract</a></li><li class="chapter-item expanded "><a href="workflow/qvmctl.html"><strong aria-hidden="true">2.4.</strong> Installing qvmctl</a></li><li class="chapter-item expanded "><a href="workflow/deploy.html"><strong aria-hidden="true">2.5.</strong> Deploying a contract</a></li><li class="chapter-item expanded "><a href="workflow/call.html"><strong aria-hidden="true">2.6.</strong> Calling a contract function</a></li><li class="chapter-item expanded "><a href="workflow/read.html"><strong aria-hidden="true">2.7.</strong> Reading contract storage</a></li></ol></li><li class="chapter-item expanded "><a href="languages/index.html"><strong aria-hidden="true">3.</strong> Supported languages</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="languages/go/index.html"><strong aria-hidden="true">3.1.</strong> Go</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="languages/go/write.html"><strong aria-hidden="true">3.1.1.</strong> Writing a contract</a></li><li class="chapter-item expanded "><a href="languages/go/compile.html"><strong aria-hidden="true">3.1.2.</strong> Compiling a contract</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="versions/index.html"><strong aria-hidden="true">4.</strong> Versions & Changelog</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="versions/v0.0.1.html"><strong aria-hidden="true">4.1.</strong> V0.0.1</a></li><li class="chapter-item expanded "><a href="versions/v0.0.2.html"><strong aria-hidden="true">4.2.</strong> V0.0.2</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>This section describes what QVM is and how it works in general on a high level to get familiar with the architecture before you start building on it.</p>
<h2 id="what-is-qvm"><a class="header" href="#what-is-qvm">What is QVM?</a></h2>
<p>QVM is the world's first blockchain Virtual Machine which is capable of executing statically linked ELF Linux binaries in a deterministic way so that they can be used for smart contracts.
Such smart contract instances are launched inside a hardware separated sandbox through CPU level virtualization and are exposed to a synthetic Linux kernel which translate non-determininistic syscalls to patched variants which provide output cmopatible with a vanilla kernel.</p>
<h3 id="example-qvm-runtime-patches"><a class="header" href="#example-qvm-runtime-patches">Example QVM runtime patches</a></h3>
<ul>
<li>Requesting random bytes would return a byte sequence derived from the previous block's hash. While this is not random, it is deterministic and compatible with the getrandom() syscall.</li>
<li>Getting the current time via the time() syscall would always return the previous block's timestamp. Again, while this does provide the exact time (as it will mostly be a couple seconds late), but it will be also deterministic all across the entire planet on each and every executing node.</li>
</ul>
<h3 id="key-initiatives"><a class="header" href="#key-initiatives">Key initiatives</a></h3>
<p>The key is that developers:</p>
<ul>
<li>Do not need to deal with any such quirks and workarounds when they are writing contracts</li>
<li>Feel like they are just writing regular CLI applications</li>
<li>Can build contracts in any language which can be compiled to a statically linked binary which runs on Linux. This is pretty much any language by the way!</li>
</ul>
<h2 id="architecture"><a class="header" href="#architecture">Architecture</a></h2>
<p>QVM is currently implemented during its testing phase as a Layer2 smart contract execution engine.
Currently the only supported network is Ethereum Testnet &quot;Ropsten&quot;.</p>
<h2 id="supported-languages"><a class="header" href="#supported-languages">Supported languages</a></h2>
<p>What does it mean that a language is &quot;supported&quot; by QVM? Doesn't it support <em><strong>ALL</strong></em> languages?</p>
<p>The answer is yes, QVM supports <em><strong>ALL</strong></em> languages which can be compiled to a static ELF binary compatible with Linux.
However, there is a continously expanding list of languages officially supported by QANplatform development team.</p>
<p>This means that for these languages there will be official tutorials and optimized compilers made available to ensure that contracts written in these languages run as efficient as possible and consume as little fees as absolutely required.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generic-workflow"><a class="header" href="#generic-workflow">Generic workflow</a></h1>
<p>This section describes the generics related to:</p>
<ul>
<li>How contracts can interact with QVM using a common API</li>
<li>Installing <code>qvmctl</code>, the command line interface of QVM</li>
<li>Deploying contracts using <code>qvmctl</code></li>
<li>Calling contract functions using <code>qvmctl</code></li>
<li>Reading contract storage using <code>qvmctl</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generic-api"><a class="header" href="#generic-api">Generic API</a></h1>
<p>Any contract can interact with QVM by following the generic API described below:</p>
<h2 id="reading-from-the-database"><a class="header" href="#reading-from-the-database">Reading from the database</a></h2>
<p>QVM calls specify database slots to be accessed during contract execution.
These slots are made available under their specified keys in the execution context via environment variables.</p>
<p>Let's say the decimal precision and total supply information of a token is required for read and/or write in a contract interaction, then executing the following call would make it available under the environment variables DB_TOTAL_SUPPLY and DB_DECIMALS:</p>
<pre><code>qvmctl call 0xCAFEBABE -r TOTAL_SUPPLY,DECIMALS print info
</code></pre>
<p>Then this contract would receive two command line arguments &quot;print&quot; and &quot;info&quot; and could print token information related to total supply and decimals which properties are available as environment variables as stated above.</p>
<h2 id="writing-to-the-database"><a class="header" href="#writing-to-the-database">Writing to the database</a></h2>
<p>If a contract wants to write to the database to insert and/or modify a record under a certain key, it needs to write the following instruction to the process' STDOUT:</p>
<pre><code>DBW=$KEY=$VALUE
</code></pre>
<p>For example if a token's name is updatable and is stored under the key <code>TOKEN_NAME</code>, it could be updated easily to something else like this in Golang:</p>
<pre><code class="language-go">os.Stdout.WriteString(&quot;DBW=TOKEN_NAME=NewTokenName\n&quot;)
</code></pre>
<h2 id="deleting-pruning-values-from-the-database"><a class="header" href="#deleting-pruning-values-from-the-database">Deleting (pruning) values from the database</a></h2>
<p>To prune key(s) from the database, simply output a &quot;DBP=&quot; prefixed new-line (\n) terminated line to stdout:</p>
<pre><code>DBP=removekey
</code></pre>
<p>Above line would delete the storage slot under key &quot;removekey&quot; from persistent storage.
Multiple keys can be removed either by specifying more lines prefixed with &quot;DBP=&quot;, or simply concatenating keys to be removed with ',' like this:</p>
<pre><code>DBP=removekey,removethistoo
</code></pre>
<p>Above line would delete the storage slot under key &quot;removekey&quot; and also &quot;removethistoo&quot; from persistent storage.</p>
<h2 id="writing-to-virtual-stdout"><a class="header" href="#writing-to-virtual-stdout">Writing to virtual STDOUT</a></h2>
<p>Since the &quot;real&quot; STDOUT is reserved for the specific opcodes above, writing to a &quot;virtual&quot; STDOUT is achieved as simply outputting a &quot;OUT=&quot; prefixed new-line (\n) terminated line to stdout:</p>
<pre><code>OUT=Program ran all good
</code></pre>
<p>The string &quot;Program ran all good&quot; will be emitted on-chain as event data, but not persisted to the database. This is a lot cheaper in gas fees than writing to storage, but this data is only visible to clients and not usable in a next contract interaction as it is not saved to state.</p>
<h2 id="reporting-errors"><a class="header" href="#reporting-errors">Reporting errors</a></h2>
<p>If a contract execution fails for any reason, developers can utilize normal behavior and simply write the error to STDERR.
This will mark the contract call as failed due to STDERR not being empty, and emit STDERR content (trimmed to the first 32 bytes).</p>
<p>Note that this will cause all previous instructions written to STDOUT to be discarded and call state will be set as failed, and only the bytes written to STDERR will be emitted as an on-chain event similar to how STDOUT works above.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="writing-a-contract"><a class="header" href="#writing-a-contract">Writing a contract</a></h1>
<p>Contracts can be written in several programming languages.
We provide official samples for writing smart contracts for the following:</p>
<ul>
<li><a href="workflow/../languages/go/write.html">Go</a></li>
</ul>
<p>We will keep on expanding this list continously!
Check back later if your faviourite language is not officially supported here yet.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compiling-a-contract"><a class="header" href="#compiling-a-contract">Compiling a contract</a></h1>
<p>The way how smart contracts are compiled to statically linked linux binaries depends on the programming language being used.
We provide tutorials and/or optimized compilers for the following languages:</p>
<ul>
<li><a href="workflow/../languages/go/compile.html">Go</a></li>
</ul>
<p>We will keep on expanding this list continously!
Check back later if your faviourite language is not officially supported here yet.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installing-qvmctl"><a class="header" href="#installing-qvmctl">Installing qvmctl</a></h1>
<p>The <code>qvmctl</code> CLI tool is the swiss knife for interacting with QVM.
It can be acquired and easily used through docker using the following commands:</p>
<h2 id="install-image"><a class="header" href="#install-image">Install image</a></h2>
<p><code>docker pull qanplatform/qvmctl</code></p>
<h2 id="verify-installation"><a class="header" href="#verify-installation">Verify installation</a></h2>
<p><code>docker run --rm qanplatform/qvmctl info</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deploying-a-contract"><a class="header" href="#deploying-a-contract">Deploying a contract</a></h1>
<p>Deploying a contract is done as follows:</p>
<h2 id="create-your-workspace"><a class="header" href="#create-your-workspace">Create your workspace</a></h2>
<p>A workspace is nothing else but a folder which will be mounted into the <code>qvmctl</code> docker container.</p>
<p>It will contain:</p>
<ul>
<li>A private key used for deployment and contract calls</li>
<li>The smart contract binary to be deployed</li>
</ul>
<p>To create the workspace create the <code>ws</code> directory in your current directory like this:</p>
<p><code>mkdir ws</code></p>
<h2 id="generate-a-random-private-key"><a class="header" href="#generate-a-random-private-key">Generate a random private key</a></h2>
<p>First you need a random secp256k1 private key, which is (almost) any random 32 byte sequence in a hexadecimal format with <code>0x</code> prepended to it.
If you have OpenSSL installed (most likely you have it if you are running Linux or macOS) then you can generate one easily with the following command:</p>
<p><code>echo &quot;0x&quot;$(openssl rand -hex 32) &gt; ws/privkey.txt</code></p>
<h2 id="get-some-reth-for-your-wallet"><a class="header" href="#get-some-reth-for-your-wallet">Get some rETH for your wallet</a></h2>
<p>As stated previously, QVM is tested as a Layer2 smart contract execution engine on the Ropsten Ethereum testnet.
First you will need at least 1 rETH so you can play around qith QVM, because fees related to the operations must be paid on the testnet as well.</p>
<p>You can get some rETH for your wallet on this website for example: <a href="https://faucet.egorfine.com">https://faucet.egorfine.com</a></p>
<h2 id="copy-the-compiled-contract-binary-to-your-workspace"><a class="header" href="#copy-the-compiled-contract-binary-to-your-workspace">Copy the compiled contract binary to your workspace</a></h2>
<p>This simply means copying the binary file you have compiled with static linking in the step which is <a href="workflow/./compile.html">specific for your language</a>.
After you have successfully executed the compilation, just copy the resulting binary to your workspace under the name <code>contract</code> like this:</p>
<p><code>cp /path/to/my/compiled/binary ws/contract</code></p>
<h2 id="run-the-deploy-command-of-qvmctl-using-docker"><a class="header" href="#run-the-deploy-command-of-qvmctl-using-docker">Run the deploy command of <code>qvmctl</code> using docker</a></h2>
<pre><code>docker run --rm -v $(pwd)/ws:/ws qanplatform/qvmctl deploy --privkey privkey.txt contract
</code></pre>
<h2 id="what-happens-under-the-hood"><a class="header" href="#what-happens-under-the-hood">What happens under the hood?</a></h2>
<h3 id="upload"><a class="header" href="#upload">Upload</a></h3>
<ul>
<li>Deployment fees are estimated based on your contract size</li>
<li>Balance check is performed whether your wallet address has enough funds to cover the fee</li>
<li>Your contract binary is pinned to IPFS</li>
<li>A checksum of the binary's integrity is generated</li>
<li>The above checksum is signed with your private key</li>
<li>A call is made to the QVM Repository contract with your IPFS CID + the signature</li>
<li>Fees are either paid during this call or the whole call fails</li>
</ul>
<h3 id="download"><a class="header" href="#download">Download</a></h3>
<ul>
<li>The QVM Repository contract emits a Deployment event upon successful deployment</li>
<li>QVM Executor nodes will download the binary based on the IPFS CID</li>
<li>They will cryptographically prove to the QVM Repository that the contract has been downloaded indeed</li>
<li>The QVM Repository contract verifies the submitted cryptographic proof to ensure Executors have the binary</li>
<li>If above verification verification was successful then the contract is Registered and is now callable</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="calling-a-contract-function"><a class="header" href="#calling-a-contract-function">Calling a contract function</a></h1>
<p>Contracts can be called by their address.
There are various pieces of data one can/should pass to a contract call in order to make it succeed.</p>
<p>The general syntax of a contract call is executed as follows:</p>
<pre><code class="language-sh">docker run --rm qanplatform/qvmctl call \
    -m $RAM_BYTES \
    -t $TIMEOUT_MILLISEC \
    -r $DB_READ_SLOTS \
    -w $DB_WRITE_SLOTS_COUNT \
    --privkey $PRIVKEY_PATH \
    $CONTRACT_ADDR
    $ARG1 $ARG2 $ARGN
</code></pre>
<p>The arguments prepended with a <strong>$</strong> sign mean the following:</p>
<ul>
<li>$RAM_BYTES: How much RAM the contract needs to execute the requested operation successfully</li>
<li>$TIMEOUT_MILLISEC: How much time the contract needs to execute the requested operation successfully</li>
<li>$DB_READ_SLOTS: The Database fields to be read and passed to the execution environment, separated by commas</li>
<li>$DB_WRITE_SLOTS_COUNT: How many database fields this operation will write to after successful execution</li>
<li>$PRIVKEY_PATH: Path to a file which contains the private key for a wallet which has enough funds to execute the call</li>
<li>$CONTRACT_ADDR: Address of the smart contract to be called</li>
<li>$ARG{N}: Arguments passed to the smart contract binary during execution</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reading-contract-storage"><a class="header" href="#reading-contract-storage">Reading contract storage</a></h1>
<p>It is easy to read any database field of any contract.</p>
<h2 id="read-a-single-field"><a class="header" href="#read-a-single-field">Read a single field</a></h2>
<p>To read a single field execute the following command:</p>
<pre><code class="language-sh">docker run --rm qanplatform/qvmctl query $CONTRACT_ADDR $DB_SLOT
</code></pre>
<p>Make sure you replace <code>$CONTRACT_ADDR</code> and <code>$DB_SLOT</code> with the right values.</p>
<h2 id="read-multiple-fields"><a class="header" href="#read-multiple-fields">Read multiple fields</a></h2>
<p>To read multiple fields execute the following command:</p>
<pre><code class="language-sh">docker run --rm qanplatform/qvmctl query $CONTRACT_ADDR $DB_SLOT1,$DB_SLOT2,$DB_SLOTN
</code></pre>
<p>Make sure you replace <code>$CONTRACT_ADDR</code> and <code>$DB_SLOT{N}</code> variables with the right values. Also pay attention that DB_SLOT variable names are separated by a comma and there is no whitespace inbetween.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="supported-languages-1"><a class="header" href="#supported-languages-1">Supported languages</a></h1>
<p>What does it mean that a language is &quot;supported&quot; by QVM? Doesn't it support <em><strong>ALL</strong></em> languages?</p>
<p>The answer is yes, QVM supports <em><strong>ALL</strong></em> languages which can be compiled to a static ELF binary compatible with Linux.
However, there is a continously expanding list of languages officially supported by QANplatform development team.</p>
<p>This means that for these languages there will be official tutorials and optimized compilers made available to ensure that contracts written in these languages run as efficient as possible and consume as little fees as absolutely required, nothing more.</p>
<h2 id="the-current-list-of-supported-languages"><a class="header" href="#the-current-list-of-supported-languages">The current list of supported languages:</a></h2>
<ul>
<li><a href="languages/./go/index.html">Go</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="go"><a class="header" href="#go">Go</a></h1>
<p>Go is the first language to be officially supported by QVM.
The reason is simple: The whole QANplatform infrastructure is written in Go, including QVM itself.
It was only natural to make Go the first language to be supported as we know &amp; love it really much!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="writing-a-contract-1"><a class="header" href="#writing-a-contract-1">Writing a contract</a></h1>
<p>This example will show how to write a smart contract in Golang.</p>
<h2 id="sample-contract-functionality"><a class="header" href="#sample-contract-functionality">Sample contract functionality</a></h2>
<p>The sample contract serves as a demonstration of general QVM logic.</p>
<p>It is capable of:</p>
<ul>
<li>registering users into the database</li>
<li>storing the last registered user's name in the database</li>
<li>echoing the previous user's name to STDOUT</li>
<li>incrementing the total registered user count</li>
<li>storing above counter in the database</li>
</ul>
<h2 id="sample-code"><a class="header" href="#sample-code">Sample code</a></h2>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;os&quot;
	&quot;strconv&quot;
)

func main() {

	// THIS SAMPLE ONLY SUPPORTS THE &quot;register&quot; FUNCTION
	if len(os.Args) == 3 &amp;&amp; os.Args[1] == &quot;register&quot; {

		// GET THE CURRENT USER'S NAME
		previousName := os.Getenv(&quot;DB_USER_CURRENT&quot;)

		// OR DEFAULT TO &quot;unknown&quot; IF THIS IS THE FIRST CALL
		if len(previousName) == 0 {
			previousName = &quot;unknown&quot;
		}

		// GET THE TOTAL USER COUNT
		totalUserCount, _ := strconv.Atoi(os.Getenv(&quot;DB_TOTALUSERS&quot;))

		// WRITE PREVIOUS USER NAME TO STDOUT
		os.Stdout.WriteString(fmt.Sprintf(&quot;OUT=prevname: %s\n&quot;, previousName))

		// UPDATE CURRENT USER NAME BY WRITING IT TO DB
		os.Stdout.WriteString(fmt.Sprintf(&quot;DBW=USER_CURRENT=%s\n&quot;, os.Args[2]))

		// STORE USER NAME UNDER A STORAGE SLOT FOR PERSISTENCE (CURRENT GETS OVERWRITTEN ON EACH CALL)
		os.Stdout.WriteString(fmt.Sprintf(&quot;DBW=USER_%d=%s\n&quot;, totalUserCount, os.Args[2]))

		// INCREMENT THE TOTAL USER COUNT
		os.Stdout.WriteString(fmt.Sprintf(&quot;DBW=TOTALUSERS=%d\n&quot;, totalUserCount+1))
		os.Exit(0)
	}
    if len(os.Args) &gt;= 2 {
        os.Stderr.WriteString(fmt.Sprintf(&quot;Wrong CMD:%s\n&quot;, os.Args[1]))
        os.Exit(1)
    }
    os.Stderr.WriteString(&quot;Wrong args!\n&quot;)
    os.Exit(1)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compiling-a-contract-1"><a class="header" href="#compiling-a-contract-1">Compiling a contract</a></h1>
<p>When compiling a Go contract one wants to reduce the resulting binary size to the bare minimum possible to save on deployment fees, since that metric is tied only to the size of the deployed binary.</p>
<p>As a good rule of thumb is to always strip DWARF, symbol table and debug info. To achieve that build with the following flags like the below example:</p>
<p><code>go build -ldflags '-s -w'</code></p>
<p>We will provide an optimized compiler for Go which will shrink the binary size (and as a result the deployment fees!) by an order of magnitude.
The sample provided compiles to a ~200k sized binary instead of ~1.3M one with information stripped as recommended above or ~1.8M without removing those!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="versions"><a class="header" href="#versions">Versions</a></h1>
<p>This section serves as a changelog mostly and lists features of certain versions.
It also discusses limitations of each version and what is planned to be mitigated in the next release.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="v001"><a class="header" href="#v001">V0.0.1</a></h1>
<p>This version was used for internal testing prior to the first publicly released version which is <a href="versions/./v0.0.2.html">v0.0.2</a>.
For this reason this was not documented in detail.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="v002"><a class="header" href="#v002">V0.0.2</a></h1>
<h2 id="new-features"><a class="header" href="#new-features">New features</a></h2>
<ul>
<li>Expose DB key+value pairs as environment variables to the execution context</li>
<li>Design common STDIO based API easily accessible from any language to interact with QVM</li>
<li>Enable forwarding STDERR/STDOUT to be emitted as events</li>
<li>Cryptographically provable contract download &amp; registration</li>
<li>ASCII encoders for DB read/write</li>
</ul>
<h2 id="limitations"><a class="header" href="#limitations">Limitations</a></h2>
<ul>
<li>Database keys and values are limited to 32 bytes</li>
<li>Database keys and values can be only ASCII encoded</li>
<li>STDIO of contract execution result is limited to 32 bytes</li>
<li>Events cannot be emitted by contracts</li>
<li>Exit codes of contract binaries are not persisted</li>
<li>Fixed QVM memory allocation</li>
<li>Storage of other contracts cannot be accessed</li>
<li>Architecture is distributed, but not truly decentralized yet</li>
<li>Various instructions do not have proper economics behind them</li>
<li>Royalty features are not yet implemented</li>
<li>Value transfers (transferring rETH from QVM) instructions not ready yet</li>
</ul>
<h2 id="roadmap-to-v003"><a class="header" href="#roadmap-to-v003">Roadmap to v0.0.3</a></h2>
<ul>
<li>Write ERC20 equivalent contract sample in Go</li>
<li>Lift limitation of DB keys and values length</li>
<li>Lift limitation of STDIO length</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
